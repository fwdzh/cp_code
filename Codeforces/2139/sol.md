# [Codeforces Round 1048 (Div. 2)](https://codeforces.com/contest/2139)

## E

给一颗以 1 为根节点的树，每个节点都有一个权值 0 或 1，定义树的美丽值等于所有的从根节点到叶子节点的路径的权值组成字符串的最长公共子序列的长度。

要求分配恰好 $k$ 个 1 和 $n - k$ 个 0 作为点权，输出可以达到的最大的美丽值。

### solution

首先我们可以确定最大的可能的答案是所有叶子的最小深度 $d$ = min $dep_u$，因为最长公共子序列的长度显然不会比字符串的长度更长。

先考虑一种特殊情况，所有叶子节点的深度都相同。如果我们想达到最大的答案 $d$，到所有叶节点得到的字符串必须相同，这意味着对于任意深度相同的节点，它们的权值必须相同。

对于每一个深度 $i$，我们将所有深度为 $i$ 的点作为第 $i$ 组 （假设根节点深度为 1）。对于每一组，所有组内的节点必须拥有相同的权值。让第 $1, \dots, d$ 组的大小为 $c_1, \dots, c_d$。现在这个问题可以看作一个背包问题，你有 $d$ 个重量为 $c_1, \dots, c_d$ 的物品。我们需要解决你是否可以从 $c$ 中取出一些物品，使得它们的和为 $k$。这可以在 $O(n ^ 2)$ 解决。

如果最大的答案 $d$ 不能达到，我们可以证明你一定可以达到 $w - 1$。对于从第 $1$ 组到第 $d$ 组，如果哪种权值剩下至少 $c_i$ 种，我们就为这一组分配这个值。由于所有的叶节点的深度相同，$c_d$ 一定是数组的最大值，所以一定可以为 $1$ 到 $d - 1$ 组选择一个值。然后自由分配剩下的值给最后一组（那些都是叶子节点）..

现在考虑普遍的情况，所有的叶子节点的深度不相同。如果我们想达到答案 $d$，我们需要选择 $d$ 个组。对于每一个叶节点 $v$，必定存在一个第 $d$ 组种的点是 $v$ 的一个祖先。对于每一个 $2 \le i \le d$，对于每一个在第 $i$ 组种的 $v$，一定有一个第 $i - 1$ 组种的点是 $v$ 的一个祖先。所有的同一组种的点都有相同的权值。假设第 $i$ 组的权值是 $l_i$，那么我们可以得到 LCS = $l_1l_2\dots l_d$，长度为 $d$。

我们仍然可以把所有深度为 $1 \le i \le d$ 的点作为第 $i$ 组。对于所有的深度 $> d$ 的节点，我们可以随意设置它们的权值。我们可以将它们看作背包问题中重量为 $1$ 的物品。

我们可以证明最佳的方式是选择 $d$ 组。如果某些节点 $u$ 的深度 $\le d$ 而没有被选择，一定会有某些被选进某些组里的点在 $u$ 的子树中，因为从根节点到 $u$ 的路径的少于 $d$ 个节点。如果最小的组
