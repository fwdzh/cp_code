// 你醒来，发现自己回到了大一……
// 这一次，你下定决心：要成为 Candidate Master。
#include<bits/stdc++.h>
using namespace std;
// created: 2025-06-25 22:16:33
void solve(){
    int n, k;
    cin >> n >> k;
    vector<int> a(n + 1);
    for(int i = 1; i <= n; i++)
        cin >> a[i];
    sort(a.begin() + 1, a.end());
    auto check = [&](auto x) -> bool{
        int c1 = 0, c2 = 0;
        long long s1 = 0, s2 = 0;
        for(int i = 1; i <= n; i++){
            if(a[i] <= x){
                c1++;
                s1 += x - a[i];
            }else{
                c2++;
                s2 += a[i] - x;
            }
        }
    };
    int lo = 0, hi = int(1e6) + 1;
    while(lo < hi - 1){
        int mid = (lo + hi) >> 1;
        if(check(mid)) lo = mid;
        else hi = mid;
    }
    
}
/* <think>
有 n 条道路，初始时第 i 条道路上有 a_i 辆车，
每辆车通过的时间为 1s，司机每等一秒，愤怒值就会 +1
可以自由的给司机换车道，可以任何时间换到任何车道，但会增加 k 的愤怒值
求最小的所有司机的总愤怒值

如果每个车道的车的数量是一样多的，那么肯定无需交换
即使交换，最多也就是交换到每个车道的车辆一样多
肯定无需多次交换，并且时间也是无所谓的，可以在一开始决定好怎么分配
交换操作减少的愤怒值为，那个司机前面的车辆数 - 去的新队伍的车辆数
并且这个值一定大于k，否则没必要进行操作

其实上次稍微看了眼题解，说是啥二分，然后好像处理很复杂，然后就没看了
那我接着二分再稍微想一下。
每一列总值不超过 1e12，总答案不超过1e17，所以二分是可能的
确定了一个答案，怎么去check呢？似乎不是很好搞的。
我们如果知道最终每列是多少个人，就比较好写了

好像最终答案只与最终每列多少人有关，于是可以算出多少人移动了
并且最大的列的人数必然都会转移到最小的列吧，且人数差会在 k 比较好，
于是无法继续交换了

不对好像也不一定，就是比如最大的和最小的换完了，然后第二小的可能无法和第二大的换了

最终的状态，一定是不存在两个车道 且车辆数的差值 > k + 1
但是我们不好去搞啊
最大的和最小的直接操作完的话，他们两就都不能继续和别人用了
我们最终的效果 是不是还是希望所有的列的长度尽量接近？在操作次数也不太多的情况下。
如果交换一次都亏了的话，那肯定不会交换，然后是否是所有人尽量接近就行？

先排个序
感觉我们先二分第一个最大能变成多少
第二个最大能变成多少
直到不能变大 则可以break了
这个好像不难判断
直接算 能让它增加到最多多少
然后减去前缀的这个值 那么就是自己这个能变到多大
其实是不是不太行，复杂度，然后具体怎么做，可能也不太行
这里只是随便想一下，感觉也是做了一些思考了，题解等会还是启动一下吧

属于是思考得还没deepseek多吧。。。

二分最小的车辆数量

</think> */
int main(){
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
    int t; cin >> t; while(t--)
    solve(); return 0;
}